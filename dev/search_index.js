var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = ManifoldFlows","category":"page"},{"location":"#ManifoldFlows","page":"Home","title":"ManifoldFlows","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ManifoldFlows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ManifoldFlows]","category":"page"},{"location":"#ManifoldFlows.Relaxation-Tuple{AbstractVector}","page":"Home","title":"ManifoldFlows.Relaxation","text":"Relaxation(alph::AbstractVector; T=Float32, m = matrix_that_maps_index_to_vector)\n\nCreates a Relaxation struct, which maps discrete tokens to continuous points and back again.\n\n\n\n\n\n","category":"method"},{"location":"#ManifoldFlows.angleaxis_stack-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T","page":"Home","title":"ManifoldFlows.angleaxis_stack","text":"angleaxisstack(R::AbstractArray{T, 3})\n\nConvert a stack of 3-by-3-by-N rotation matrices to a row vector of angles and a 3-by-N matrix of axis...es?\n\n\n\n\n\n","category":"method"},{"location":"#ManifoldFlows.batch_flowstate-Tuple{Tuple{Vararg{Flow}}, Tuple{Vararg{AbstractArray}}}","page":"Home","title":"ManifoldFlows.batch_flowstate","text":"batch_flowstate(statetuple::Tuple{Vararg{AbstractArray}}, flowtuple::Tuple{Vararg{Flow}})\n\nConverts a tuple of abstract arrays and a tuple of Flows, into a tuple of Flow-appropriate FlowStates.\n\n\n\n\n\n","category":"method"},{"location":"#ManifoldFlows.bcds2quats-Tuple{AbstractMatrix{<:Real}}","page":"Home","title":"ManifoldFlows.bcds2quats","text":"bcds2quats(bcd::AbstractArray{<: Real, 2})\n\nConvert a 3xN array of partial quaternions to an array of (flat) unit quaternions.\n\n\n\n\n\n","category":"method"},{"location":"#ManifoldFlows.flow-Tuple{Tuple{Vararg{Flow}}, Tuple{Vararg{FlowState}}, Any}","page":"Home","title":"ManifoldFlows.flow","text":"flow(f::Flow, x0::FlowState, model; steps = 100, tracker = NullTracker())\n\nSamples from the distribution implied by the model under the Flow f, starting from x0. f and x0 can also be tuples, with matches components. steps can be an integer, in which case a linear schedule is used, or a vector of times to specify the schedule. If a tracker is supplied, the sample paths are tracked.\n\n\n\n\n\n","category":"method"},{"location":"#ManifoldFlows.interpolate-Union{Tuple{T}, Tuple{Union{EuclideanFlow, RelaxedDiscreteFlow}, VectorFlowState{T, A} where A<:AbstractMatrix{T}, VectorFlowState{T, A} where A<:AbstractMatrix{T}, Any}} where T","page":"Home","title":"ManifoldFlows.interpolate","text":"interpolate(f::Flow, x0::A, x1::A, t::T) where A::FlowState{T}\n\nGeodesic interpolation between two FlowStates. t` must be a scalar, or row vector. The flow states are interpolated regardless of the mask, and the output mask is the logical AND of the two input masks.\n\n\n\n\n\n","category":"method"},{"location":"#ManifoldFlows.log_rot_stack-Union{Tuple{AbstractArray{T, 3}}, Tuple{T}} where T","page":"Home","title":"ManifoldFlows.log_rot_stack","text":"logrotstack(R::AbstractArray{T, 3})\n\nCalculate the logarithmic map of each rotation in a stack of 3-by-3-by-N rotation matrices.\n\nlogrotstack(A) is calculating the same thing as stack([log(A[:,:,i]) for i in 1:size(A,3)])\n\n\n\n\n\n","category":"method"},{"location":"#ManifoldFlows.loss-Union{Tuple{T}, Tuple{Union{EuclideanFlow, RelaxedDiscreteFlow}, AbstractArray{T}, VectorFlowState{T, A} where A<:AbstractMatrix{T}, VectorFlowState{T, A} where A<:AbstractMatrix{T}, Union{AbstractMatrix{T}, T}}} where T<:Real","page":"Home","title":"ManifoldFlows.loss","text":"loss(f::Flow, x̂1::A, x1::A, xt::A, t::T; masked = false, eps = T(0.01), pow = 2) where A::FlowState{T}\n\nCompute a loss between the predicted end point x̂1 and the true end point x1, given the starting point xt and the time t. These should be considered as \"default\" losses, and you might need to adapt and adjust them for your problem.\n\n\n\n\n\n","category":"method"},{"location":"#ManifoldFlows.perturb!-Union{Tuple{T}, Tuple{Union{EuclideanFlow, RelaxedDiscreteFlow}, VectorFlowState{T, A} where A<:AbstractMatrix{T}, Real}} where T","page":"Home","title":"ManifoldFlows.perturb!","text":"perturb!(f::Flow, x::A, σ::T) where A::FlowState{T}\n\nPerturb the flow by a random amount, respecting the manifold, but do not change states where mask is false.\n\n\n\n\n\n","category":"method"},{"location":"#ManifoldFlows.quats2rots-Tuple{Any}","page":"Home","title":"ManifoldFlows.quats2rots","text":"quats2rots(q)\n\nConvert a 4-by-N array of quaternions to a 3-by-3-by-N array of rotation matrices.\n\n\n\n\n\n","category":"method"},{"location":"#ManifoldFlows.randrot-Tuple{Random.AbstractRNG, Real}","page":"Home","title":"ManifoldFlows.randrot","text":"randrot(σ²)\n\nGenerate a random rotation matrix, with each element drawn from the exponential map of a normal distribution with variance σ².\n\n\n\n\n\n","category":"method"},{"location":"#ManifoldFlows.relax-Tuple{Any, Relaxation}","page":"Home","title":"ManifoldFlows.relax","text":"relax(seq::AbstractVector, r::Relaxation)\n\nConverts a sequence of discrete tokens to a matrix (where each column can be thought of as a multivariant \"point\").\n\n\n\n\n\n","category":"method"},{"location":"#ManifoldFlows.rot_identity_stack-Tuple{Any, Any}","page":"Home","title":"ManifoldFlows.rot_identity_stack","text":"rotidentitystack(T,N)\n\nGenerate a stack of 3-by-3-by-N identity matrices of type T.\n\n\n\n\n\n","category":"method"},{"location":"#ManifoldFlows.sinkhorn-Union{Tuple{T}, Tuple{Any, T}} where T","page":"Home","title":"ManifoldFlows.sinkhorn","text":"sinkhorn(C, λ; iters=50, standardize = true)\n\nReturns the \"plan\" from the Sinkhorn algorithm for optimal transport, given a cost matrix C and regularization parameter λ. If standardize is true, then the cost matrix is standardized by dividing by its standard deviation which can help with numerical stability.\n\n\n\n\n\n","category":"method"},{"location":"#ManifoldFlows.slerp_stack-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractArray{T, 3}, AbstractArray{T}}} where T","page":"Home","title":"ManifoldFlows.slerp_stack","text":"slerp(a,b,t)\n\nInterpolation between two 3-by-3-by-N stacks of rotation matrices,performing Spherical linear interpolation (Slerp) on each pair of rotation matrices.\n\n\n\n\n\n","category":"method"},{"location":"#ManifoldFlows.unrelax-Tuple{AbstractArray, Relaxation}","page":"Home","title":"ManifoldFlows.unrelax","text":"unrelax(points::AbstractArray, r::Relaxation)\n\nConverts a continuous matrix (where each column can be thought of as a multivariant \"point\") to a sequence of discrete tokens.\n\n\n\n\n\n","category":"method"}]
}
